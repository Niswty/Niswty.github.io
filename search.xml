<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node-js-npm-Webpack]]></title>
    <url>%2F2019%2F08%2F09%2FNode-js-npm-Webpack%2F</url>
    <content type="text"><![CDATA[Node.jsNode.js介绍Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 Node.js安装window安装 https://nodejs.org/en/ 傻瓜式安装、安装时未勾选环境变量则需自己配置。 打开cmd，输入node，打上一段JS验证一下。 npmnpm是JavaScript这门语言的第三方库管理工具 安装好Node.js之后，默认已经安装好了npm包管理工具，打开输入cmd输入npm测试一下。 使用npm包管理工具安装第三方库全局安装与本地安装、开发依赖和生产依赖 https://segmentfault.com/a/1190000017787636 npm 全局安装和本地安装 https://blog.csdn.net/qq_27095799/article/details/81908158 全局安装 全局方式安装的npm包，全局可用。任何项目都可以使用 1npm install -g &lt;package&gt; 本地安装 方式一： 12npm initnpm install vue@2.5.17 特点： 123- 会把包安装到node_modules目录中- 不会新增并修改package.json- 运行npm install不会自动安装该包 方式二： 12npm initnpm install vue@2.5.17 --save 特点： 123- 会把包安装到node_modules目录中- 会在package.json的dependencies属性下添加包- 运行npm install命令时，会自动安装包到node_modules目录中 方式三： 12npm initnpm install vue@2.5.17 --save-dev 特点 123- 会把包安装到node_modules目录中- 会在package.json的Devdependencies属性下添加包- 运行npm install命令时，不会自动安装包到node_modules目录中 卸载全局包 1npm uninstall &lt;package&gt; -g 卸载本地包 12npm uninstall &lt;package&gt; -S, --save: Package will be removed from your dependencies.npm uninstall &lt;package&gt; -D, --save-dev: Package will be removed from your devDependencies. 使用步骤创建文件夹，初始化为npm环境 123mkdir myprojectcd myprojectnpm init npm init初始化的环境 123456789101112131415161718192021222324252627Press ^C at any time to quit.name: (npm-demo)version: (1.0.0)description:entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to F:\S14练习\day89\npm-demo\package.json:&#123; "name": "npm-demo", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125;Is this ok? (yes) 按需填入上述信息，最后输入yes，项目环境初始化完毕。如果使用默认信息，可以直接使用npm init -y进行初始化。 123456789name 项目名称version 项目的版本号description 项目的描述信息entry point 项目的入口文件test command 项目启动时脚本命令git repository 如果你有 Git 地址，可以将这个项目放到你的 Git 仓库里keywords 关键词author 作者license 项目要发行的时候需要的证书 查看package： 1npm is &lt;package&gt; 更新package： 1npm update &lt;package&gt; 搜索package： 1npm serach &lt;package&gt; package.json详解 12345678910111213141516171819202122"private": true, "dependencies": &#123; "antd": "^2.11.1", "classnames": "^2.2.5" &#125;, "devDependencies": &#123; "axios": "^0.15.3", "babel-eslint": "^6.1.2" &#125;, "bin": &#123; "dk-cli": "./bin/dk-cli.js" &#125;, "scripts": &#123; "start": "node index.js" &#125;, "engines": &#123; "node": "&gt;=6.9.0", "npm": "&gt;=3.10.10" &#125; "publishConfig": &#123; "registry": "http://gongsineibu/nexus/repository/npm-hosted/" &#125; private可选字段，布尔值。如果 private 为 true，npm 会拒绝发布。这可以防止私有 repositories 不小心被发布出去; dependencies与devDependencies 在开发阶段，我们需要对开发的模块进行单元测试，这时在开发环境 devDependencies 下就要安装单元测试模块 Mocha。 在生产环境 dependencies，用户直接使用项目，此时项目的开发已全部完成。这时就不需要单元测试模块了，再加上只会影响性能。 dependencies 指定了项目生产环境时所依赖的模块, devDependencies 制定了项目开发环境时所依赖的模块。 scripts该字段指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。 下面的设置指定了npm run dev、npm run bulid、npm run unit、npm run test、npm run lint时，所要执行的命令； 1234567"scripts": &#123; "dev": "node build/dev-server.js", "build": "node build/build.js", "unit": "cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run", "test": "npm run unit", "lint": "eslint --ext .js,.vue src test/unit/specs" &#125; engines字段指定依赖的node版本 publishConfig 当我们开发完自己的项目想要将它发布到 Npm 仓库就需要使用这个属性。默认情况下我们是往 Npm 公共仓库中发布包，默认地址是：https://www.npmjs.com/，此时在 package.json 文件中可以不加这个属性。 但是如果公司内部搭建了 Npm 私有仓库，此时发布包就不是往 https://www.npmjs.com/ 这个地址上发布了，而是公司内部提供的地址，如：http://gongsineibu/nexus/repository/npm-hosted/。此时配置如下： 123"publishConfig": &#123; "registry": "http://gongsineibu/nexus/repository/npm-hosted/" &#125; publicConfig 字段决定了我们的包发布到哪里。 https://pizzali.github.io/2018/10/29/npm/ npm与package.json详解 https://blog.csdn.net/xingmeiok/article/details/90299089 webpackwebpack介绍webpack安装123npm install -g webpack webpack-cli或者npm install webpack webpack-cli --save 概念入口文件入口起点(entry point)指示 Webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，Webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 出口文件出口文件告诉 Webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。 loaderloader让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 使用123npm init -ynpm install webpack webpack-cli --savewebpack打包 在webpack-demo目录下面创建一个src目录，用于存放我们程序的原始文件如src/index.js，然后在webpack-demo目录下面创建一个index.html文件，用于使用打包后的出口文件，新的目录结构如下： 我们在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件，Webpack4默认的输出文件为dist/main.js。 12345678910111213&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;script src="./dist/main.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; index.js代码： 123let greeting = "Hello Webpack!";console.log(greeting); webpack4打包123webpack --mode development/production 进行模式切换 development 开发者模式 打包默认不压缩代码 production 生产者模式 上线时使用，压缩代码。 默认是这个模式 Webpack4固定入口目录为src，入口文件必须为index.js，打包后文件在新增的dist目录下, 出口文件为main.js，开始打包。 新目录： 打开index.html文件的控制台： 使用webpack进行ES6的模块化编程src目录下新建hello.js文件： 1234567let aa = "hello aa";let bb = "hello bb";let cc = "hello cc";export &#123;aa, bb&#125;;export default cc; index.js中import： 123456import &#123;aa, bb&#125; from "./hello.js";import cc from "./hello";console.log(aa);console.log(bb);console.log(cc); 重新打包，查看index.html： 注意，每一个文件只能有一个export default，import会将没有命中的变量名映射到export default导出的数据上面。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6基本语法]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[ECMAScript 6 入门] http://es6.ruanyifeng.com/ECMAScript 6简介ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。 ECMA是“European Computer Manufacturers Association”的缩写，中文称欧洲计算机制造联合会。是1961年成立的旨在建立统一的电脑操作格式标准–包括程序语言和输入输出的组织。 ES6之变量let变量块级作用域ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href=""&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; &#123; var a = 18; let b = 28; &#125; console.log(a); // 18 console.log(b); // b is not defined &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; let应用在for循环中 var声明的变量 1234567var a = []; for (var i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[5](); // 10 var声明的变量为全局作用域，所以循环最后，数组a中的成员指向同一个i，i为10。 let声明的变量 1234567var a = []; for (let i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[5](); // 5 let声明的变量存在块级作用域，所以输出6。 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。 1234567// var声明console.log(a);var a = 12; // undefined// let声明console.log(b);let b = 12; // 报错 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 12345678910function func() &#123; let a = 10; var a = 20; &#125;func(); // 报错function func() &#123; let a = 10; let a = 20; &#125;func(); //报错 因此，不能在函数内部重新声明参数。 12345678910function func(arg) &#123; let arg; &#125;func() // 报错function func(arg) &#123; &#123; let arg; &#125; &#125;func() // 不报错 const变量 const声明一个常量，声明之后不能改变。声明之后必须立即赋值。 1234const PI = 3.1415;PI = 3; // 报错const a; // 报错 存在块级作用域 不存在提升，存在暂时性死区 与let一样不可重复声明 本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 如果真的想将对象冻结，应该使用Object.freeze方法。 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 变量的解构赋值数组的解构赋值1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 不完全解构 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 对象的解构赋值123let &#123; foo, bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;foo // "aaa"bar // "bbb" 与数组一样，解构也可以用于嵌套结构的对象。 1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 另一个例子 12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。 默认值 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 字符串的解构赋值123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。 12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。 12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 模板字符串12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1let greeting = `\`Yo\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。 123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; ES6之函数的扩展函数参数的默认值ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 123if (typeof y === 'undefined') &#123; y = 'World';&#125; S6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; 参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 使用参数默认值时，函数不能有同名参数。 12345678910// 不报错function foo(x, x, y) &#123; // ...&#125;// 报错function foo(x, x, y = 1) &#123; // ...&#125;// SyntaxError: Duplicate parameter name not allowed in this context 与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property 'x' of undefined 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。 123456789function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125;) &#123; console.log(method);&#125;fetch('http://example.com', &#123;&#125;)// "GET"fetch('http://example.com')// 报错 上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。 123456function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch('http://example.com')// "GET" 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。 123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 123456function foo(x = 5, y = 6) &#123; console.log(x, y);&#125;foo(undefined, null)// 5 null 上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。 箭头函数ES6中引入了箭头函数，其实就相当于Python当中的匿名函数lambda，接下来我们详细看看箭头函数的使用方式以及使用箭头函数时需要注意的地方。 箭头函数的定义 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: "Temp" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果 12let foo = () =&gt; &#123; a: 1 &#125;;foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 === 0;const square = n =&gt; n * n; 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 注意点 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成 ES5 的代码如下。 123456789101112131415/ ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。 请问下面的代码之中有几个this？ 123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: 'inner' &#125;)() ];&#125;).call(&#123; x: 'outer' &#125;);// ['outer'] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 ES6之类的定义ES5实例化对象的方式12345678910111213141516&lt;script&gt; // ES5中使用构造函数的方式创建实例对象 function Foo(username, age, hobby) &#123; this.username = username; this.age = age; this.hobby = hobby; &#125; Foo.prototype.showInfo = function () &#123; console.log(this.username, this.age, this.hobby); &#125;; let foo = new Foo("peiqi", 73, "girls"); foo.showInfo(); &lt;/script&gt; ES6实例化对象的方式12345678910111213141516171819202122&lt;script&gt; // ES6中使用class创建类，并使用new方法创建实例对象 // 我们需要注意： // 1. 必须要有constructor方法，如果没有，默认会给一个空的constructor方法 // constructor () &#123;&#125;; // 2. 必须要用new调用，不能直接调用，否则报错； class Foo &#123; constructor (username, age, hobby) &#123; this.username = username; this.age = age; this.hobby = hobby; &#125; showInfo () &#123; console.log(this.username, this.age, this.hobby); &#125; &#125; let foo = new Foo("pizza", 18, "girls"); foo.showInfo(); &lt;/script&gt; 类的继承123456789101112131415161718192021222324252627282930// ES6中类的继承// 第一步，使用class关键字定义类class Baoyuan &#123; // 第二步，使用constructor构造函数，初始化实例 constructor (username, age) &#123; this.username = username; this.age = age; this.money = 100000; &#125; showInfo () &#123; console.log(this.username, this.age, this.money); &#125;&#125;let baoyuan = new Baoyuan("baoyuan", 20);baoyuan.showInfo();class Alex extends Baoyuan &#123; constructor (username, age) &#123; super(); this.username = username; this.age = age; &#125;&#125;let alex = new Alex("alex", 2);alex.showInfo(); 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 父类的静态方法，也会被子类继承。 12345678910class A &#123; static hello() &#123; console.log('hello world'); &#125;&#125;class B extends A &#123;&#125;B.hello() // hello world]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my new post]]></title>
    <url>%2F2019%2F07%2F05%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 非线性svm与核函数当分类问题是非线性，可以使用非线性svm，主要的特点是利用核函数。 核技巧非线性分类问题😵对于训练数据集，能用一个超曲面将正负例正确分开，则称该问题为非线性可分问题非线性问题往往不好求解，所以进行非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题求解原来的非线性问题。💃💃 线性分类法求解非线性分类问题：使用变换，将原空间数据映射到新空间；然后在新空间利用线性分类学习方法从训练集中学习分类模型。核技巧就属于这样的方法 核技巧应用到svm的基本思想：通过非线性变换将输入空间XX(欧氏空间&amp;离散集合)对应于特征空间HH(希尔伯特空间)，使得输入空间的超曲面模型对应特征空间的超平面模型，最后分类问题的学习任务是通过在特征空间在求解线性支持向量机就可以完成。如果存在一个从XX到HH的映射，映射关系表示如下：ϕ(x):X→Hϕ(x):X→H 使得对所有的x,z∈Xx,z∈X，函数K(x,z)K(x,z)满足条件K(x,z)=ϕ(x)⋅ϕ(z)K(x,z)=ϕ(x)⋅ϕ(z) 则称K(x,z)K(x,z)为核函数，ϕ(x)ϕ(x)为映射函数，ϕ(x)⋅ϕ(z)ϕ(x)⋅ϕ(z)为ϕ(x)和ϕ(z)ϕ(x)和ϕ(z)内积]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F04%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[非线性svm与核函数当分类问题是非线性，可以使用非线性svm，主要的特点是利用核函数。 核技巧非线性分类问题😵对于训练数据集，能用一个超曲面将正负例正确分开，则称该问题为非线性可分问题 非线性问题往往不好求解，所以进行非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题求解原来的非线性问题。💃💃 线性分类法求解非线性分类问题：使用变换，将原空间数据映射到新空间；然后在新空间利用线性分类学习方法从训练集中学习分类模型。核技巧就属于这样的方法 核技巧应用到svm的基本思想：通过非线性变换将输入空间XX(欧氏空间&amp;离散集合)对应于特征空间HH(希尔伯特空间)，使得输入空间的超曲面模型对应特征空间的超平面模型，最后分类问题的学习任务是通过在特征空间在求解线性支持向量机就可以完成。如果存在一个从XX到HH的映射，映射关系表示如下：ϕ(x):X→Hϕ(x):X→H 使得对所有的x,z∈Xx,z∈X，函数K(x,z)K(x,z)满足条件K(x,z)=ϕ(x)⋅ϕ(z)K(x,z)=ϕ(x)⋅ϕ(z) 则称K(x,z)K(x,z)为核函数，ϕ(x)ϕ(x)为映射函数，ϕ(x)⋅ϕ(z)ϕ(x)⋅ϕ(z)为ϕ(x)和ϕ(z)ϕ(x)和ϕ(z)内积]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
</search>
