<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6基本语法]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[ECMAScript 6 入门] http://es6.ruanyifeng.com/ECMAScript 6简介ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。 ECMA是“European Computer Manufacturers Association”的缩写，中文称欧洲计算机制造联合会。是1961年成立的旨在建立统一的电脑操作格式标准–包括程序语言和输入输出的组织。 ES6之变量let变量块级作用域ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href=""&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; &#123; var a = 18; let b = 28; &#125; console.log(a); // 18 console.log(b); // b is not defined &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; let应用在for循环中 var声明的变量 1234567var a = []; for (var i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[5](); // 10 var声明的变量为全局作用域，所以循环最后，数组a中的成员指向同一个i，i为10。 let声明的变量 1234567var a = []; for (let i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[5](); // 5 let声明的变量存在块级作用域，所以输出6。 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。 1234567// var声明console.log(a);var a = 12; // undefined// let声明console.log(b);let b = 12; // 报错 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 12345678910function func() &#123; let a = 10; var a = 20; &#125;func(); // 报错function func() &#123; let a = 10; let a = 20; &#125;func(); //报错 因此，不能在函数内部重新声明参数。 12345678910function func(arg) &#123; let arg; &#125;func() // 报错function func(arg) &#123; &#123; let arg; &#125; &#125;func() // 不报错 const变量 const声明一个常量，声明之后不能改变。声明之后必须立即赋值。 1234const PI = 3.1415;PI = 3; // 报错const a; // 报错 存在块级作用域 不存在提升，存在暂时性死区 与let一样不可重复声明 本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 如果真的想将对象冻结，应该使用Object.freeze方法。 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 变量的解构赋值数组的解构赋值1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 不完全解构 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 对象的解构赋值123let &#123; foo, bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;foo // "aaa"bar // "bbb" 与数组一样，解构也可以用于嵌套结构的对象。 1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 另一个例子 12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。 默认值 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 字符串的解构赋值123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。 12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。 12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 模板字符串12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1let greeting = `\`Yo\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。 123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; ES6之函数的扩展函数参数的默认值ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 123if (typeof y === 'undefined') &#123; y = 'World';&#125; S6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; 参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 使用参数默认值时，函数不能有同名参数。 12345678910// 不报错function foo(x, x, y) &#123; // ...&#125;// 报错function foo(x, x, y = 1) &#123; // ...&#125;// SyntaxError: Duplicate parameter name not allowed in this context 与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property 'x' of undefined 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。 123456789function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125;) &#123; console.log(method);&#125;fetch('http://example.com', &#123;&#125;)// "GET"fetch('http://example.com')// 报错 上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。 123456function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch('http://example.com')// "GET" 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。 123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 123456function foo(x = 5, y = 6) &#123; console.log(x, y);&#125;foo(undefined, null)// 5 null 上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。 箭头函数ES6中引入了箭头函数，其实就相当于Python当中的匿名函数lambda，接下来我们详细看看箭头函数的使用方式以及使用箭头函数时需要注意的地方。 箭头函数的定义 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: "Temp" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果 12let foo = () =&gt; &#123; a: 1 &#125;;foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 === 0;const square = n =&gt; n * n; 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 注意点 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成 ES5 的代码如下。 123456789101112131415/ ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。 请问下面的代码之中有几个this？ 123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: 'inner' &#125;)() ];&#125;).call(&#123; x: 'outer' &#125;);// ['outer'] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 ES6之类的定义ES5实例化对象的方式12345678910111213141516&lt;script&gt; // ES5中使用构造函数的方式创建实例对象 function Foo(username, age, hobby) &#123; this.username = username; this.age = age; this.hobby = hobby; &#125; Foo.prototype.showInfo = function () &#123; console.log(this.username, this.age, this.hobby); &#125;; let foo = new Foo("peiqi", 73, "girls"); foo.showInfo(); &lt;/script&gt; ES6实例化对象的方式12345678910111213141516171819202122&lt;script&gt; // ES6中使用class创建类，并使用new方法创建实例对象 // 我们需要注意： // 1. 必须要有constructor方法，如果没有，默认会给一个空的constructor方法 // constructor () &#123;&#125;; // 2. 必须要用new调用，不能直接调用，否则报错； class Foo &#123; constructor (username, age, hobby) &#123; this.username = username; this.age = age; this.hobby = hobby; &#125; showInfo () &#123; console.log(this.username, this.age, this.hobby); &#125; &#125; let foo = new Foo("pizza", 18, "girls"); foo.showInfo(); &lt;/script&gt; 类的继承123456789101112131415161718192021222324252627282930// ES6中类的继承// 第一步，使用class关键字定义类class Baoyuan &#123; // 第二步，使用constructor构造函数，初始化实例 constructor (username, age) &#123; this.username = username; this.age = age; this.money = 100000; &#125; showInfo () &#123; console.log(this.username, this.age, this.money); &#125;&#125;let baoyuan = new Baoyuan("baoyuan", 20);baoyuan.showInfo();class Alex extends Baoyuan &#123; constructor (username, age) &#123; super(); this.username = username; this.age = age; &#125;&#125;let alex = new Alex("alex", 2);alex.showInfo(); 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 父类的静态方法，也会被子类继承。 12345678910class A &#123; static hello() &#123; console.log('hello world'); &#125;&#125;class B extends A &#123;&#125;B.hello() // hello world]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my new post]]></title>
    <url>%2F2019%2F07%2F05%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 非线性svm与核函数当分类问题是非线性，可以使用非线性svm，主要的特点是利用核函数。 核技巧非线性分类问题😵对于训练数据集，能用一个超曲面将正负例正确分开，则称该问题为非线性可分问题非线性问题往往不好求解，所以进行非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题求解原来的非线性问题。💃💃 线性分类法求解非线性分类问题：使用变换，将原空间数据映射到新空间；然后在新空间利用线性分类学习方法从训练集中学习分类模型。核技巧就属于这样的方法 核技巧应用到svm的基本思想：通过非线性变换将输入空间XX(欧氏空间&amp;离散集合)对应于特征空间HH(希尔伯特空间)，使得输入空间的超曲面模型对应特征空间的超平面模型，最后分类问题的学习任务是通过在特征空间在求解线性支持向量机就可以完成。如果存在一个从XX到HH的映射，映射关系表示如下：ϕ(x):X→Hϕ(x):X→H 使得对所有的x,z∈Xx,z∈X，函数K(x,z)K(x,z)满足条件K(x,z)=ϕ(x)⋅ϕ(z)K(x,z)=ϕ(x)⋅ϕ(z) 则称K(x,z)K(x,z)为核函数，ϕ(x)ϕ(x)为映射函数，ϕ(x)⋅ϕ(z)ϕ(x)⋅ϕ(z)为ϕ(x)和ϕ(z)ϕ(x)和ϕ(z)内积]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F04%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[非线性svm与核函数当分类问题是非线性，可以使用非线性svm，主要的特点是利用核函数。 核技巧非线性分类问题😵对于训练数据集，能用一个超曲面将正负例正确分开，则称该问题为非线性可分问题 非线性问题往往不好求解，所以进行非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题求解原来的非线性问题。💃💃 线性分类法求解非线性分类问题：使用变换，将原空间数据映射到新空间；然后在新空间利用线性分类学习方法从训练集中学习分类模型。核技巧就属于这样的方法 核技巧应用到svm的基本思想：通过非线性变换将输入空间XX(欧氏空间&amp;离散集合)对应于特征空间HH(希尔伯特空间)，使得输入空间的超曲面模型对应特征空间的超平面模型，最后分类问题的学习任务是通过在特征空间在求解线性支持向量机就可以完成。如果存在一个从XX到HH的映射，映射关系表示如下：ϕ(x):X→Hϕ(x):X→H 使得对所有的x,z∈Xx,z∈X，函数K(x,z)K(x,z)满足条件K(x,z)=ϕ(x)⋅ϕ(z)K(x,z)=ϕ(x)⋅ϕ(z) 则称K(x,z)K(x,z)为核函数，ϕ(x)ϕ(x)为映射函数，ϕ(x)⋅ϕ(z)ϕ(x)⋅ϕ(z)为ϕ(x)和ϕ(z)ϕ(x)和ϕ(z)内积]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
</search>
